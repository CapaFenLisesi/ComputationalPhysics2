TITLE: Slides from FYS-KJM4411/9411 Variational Monte Carlo methods
AUTHOR: Morten Hjorth-Jensen at Department of Physics, University of Oslo, Oslo, Norway and National Superconducting Cyclotron Laboratory, Michigan State University, East Lansing, MI 48824, USA
DATE: Spring 2015


!split
===== Hello world =====

!bblock The C encounter
Here we present first the C version.

!bc cppcod
/* comments in C begin like this and end with */
#include <stdlib.h> /* atof function */
#include <math.h>   /* sine function */
#include <stdio.h>  /* printf function */
int main (int argc, char* argv[])
{
  double r, s;        /* declare variables */
  r = atof(argv[1]);  /* convert the text argv[1] to double */
  s = sin(r);
  printf("Hello, World! sin(%g)=%g\n", r, s);
  return 0;           /* success execution of the program */

!ec
!eblock

!split
===== Hello World =====

!bblock Dissection I
The compiler must see a declaration of a function before you can
call it (the compiler checks the argument and return types).
The declaration of library functions appears
in so-called ``header files'' that must be included in the program, e.g.,

!bc cppcod
   #include <stdlib.h> /* atof function */
!ec
We call three functions (atof, sin, printf)
and these are declared in three different header files.
The main program is a function called main
with a return value set to an integer, int (0 if success).
The operating system stores the return value,
and other programs/utilities can check whether
the execution was successful or not.
The command-line arguments are transferred to the main function through

!bc cppcod
   int main (int argc, char* argv[])
!ec
!eblock

!split
===== Hello World =====


!split
===== Limits, you must declare variables =====


!bblock C++ and Fortran declarations

|-------------------------------------------------------------------------|
| type in C/C++ and Fortran2008 | bits | range |
|-------l------------c-------------l--------------------------------------|
| `int/INTEGER` (2) | 16 | -32768 to 32767 |
| `unsigned int`      | 16 | 0 to 65535        |
| `signed int`        | 16 | -32768 to 32767 |
| `short int`         | 16 | -32768 to 32767 |
| `unsigned short int` | 16 | 0 to 65535       |
| `signed short int`  | 16 | $-32768$ to 32767 |
| `int/long int/INTEGER` (4) | 32 | -2147483648 to 2147483647              |
| `signed long int`   | 32 | -2147483648 to 2147483647                    |
| `float/REAL(4)`     | 32 | $3.4\times 10^{-44}$ to $3.4\times 10^{+38}$   |
| `double/REAL(8)`    | 64 | $1.7\times 10^{-322}$ to $1.7\times 10^{+308}$ |
| `long double`       | 64 | $1.7\times 10^{-322}$ to $1.7\times 10^{+308}$ |
|-------------------------------------------------------------------------|

!eblock


!split
===== Basic Matrix Features =====

!bblock Matrix properties reminder
!bt
\[
 {\bf A} =
      \left( \begin{array}{cccc} a_{11} & a_{12} & a_{13} & a_{14} \\
                                 a_{21} & a_{22} & a_{23} & a_{24} \\
                                   a_{31} & a_{32} & a_{33} & a_{34} \\
                                  a_{41} & a_{42} & a_{43} & a_{44}
             \end{array} \right)\qquad
{\bf I} =
      \left( \begin{array}{cccc} 1 & 0 & 0 & 0 \\
                                 0 & 1 & 0 & 0 \\
                                 0 & 0 & 1 & 0 \\
                                 0 & 0 & 0 & 1
             \end{array} \right)
\]
!et

The inverse of a matrix is defined by

!bt
\[
{\bf A}^{-1} \cdot {\bf A} = I
\]
!et
!eblock

!split
===== Basic Matrix Features =====

!bblock Matrix Properties Reminder

|----------------------------------------------------------------------|
|       Relations      |       Name      | matrix elements             |
|----------------------------------------------------------------------|
| $A = A^{T}$         | symmetric       | $a_{ij} = a_{ji}$            |
| $A = \left (A^{T} \right )^{-1}$ | real orthogonal| $\sum_k a_{ik} a_{jk} = \sum_k a_{ki} a_{kj} = \delta_{ij}$ |
| $A = A^{*}$          | real matrix     | $a_{ij} = a_{ij}^{*}$       |
| $A = A^{\dagger}$     |  hermitian      | $a_{ij} = a_{ji}^{*}$       |
| $A = \left (A^{\dagger} \right )^{-1}$ | unitary | $\sum_k a_{ik} a_{jk}^{*} = \sum_k a_{ki}^{*} a_{kj} = \delta_{ij}$ |
|----------------------------------------------------------------------|

!eblock




!split
===== Quantum Monte Carlo Motivation =====
!bblock
Given a hamiltonian $H$ and a trial wave function $\Psi_T$, the variational principle states that the expectation value of $\langle H \rangle$, defined through 
!bt
\[
   E[H]= \langle H \rangle =
   \frac{\int d\bm{R}\Psi^{\ast}_T(\bm{R})H(\bm{R})\Psi_T(\bm{R})}
        {\int d\bm{R}\Psi^{\ast}_T(\bm{R})\Psi_T(\bm{R})},
\]
!et
is an upper bound to the ground state energy $E_0$ of the hamiltonian $H$, that is 
!bt
\[
    E_0 \le \langle H \rangle .
\]
!et
In general, the integrals involved in the calculation of various  expectation values  are multi-dimensional ones. Traditional integration methods such as the Gauss-Legendre will not be adequate for say the  computation of the energy of a many-body system.
!eblock

!split
===== Quantum Monte Carlo Motivation =====
!bblock
The trial wave function can be expanded in the eigenstates of the hamiltonian since they form a complete set, viz.,
!bt
\[
   \Psi_T(\bm{R})=\sum_i a_i\Psi_i(\bm{R}),
\]
!et
and assuming the set of eigenfunctions to be normalized one obtains 
!bt
\[
     \frac{\sum_{nm}a^*_ma_n \int d\bm{R}\Psi^{\ast}_m(\bm{R})H(\bm{R})\Psi_n(\bm{R})}
        {\sum_{nm}a^*_ma_n \int d\bm{R}\Psi^{\ast}_m(\bm{R})\Psi_n(\bm{R})} =\frac{\sum_{n}a^2_n E_n}
        {\sum_{n}a^2_n} \ge E_0,
\]
!et
where we used that $H(\bm{R})\Psi_n(\bm{R})=E_n\Psi_n(\bm{R})$.
In general, the integrals involved in the calculation of various  expectation
values  are multi-dimensional ones. 
The variational principle yields the lowest state of a given symmetry.

!eblock


!split
===== Quantum Monte Carlo Motivation =====
!bblock
In most cases, a wave function has only small values in large parts of 
configuration space, and a straightforward procedure which uses
homogenously distributed random points in configuration space 
will most likely lead to poor results. This may suggest that some kind
of importance sampling combined with e.g., the Metropolis algorithm 
may be  a more efficient way of obtaining the ground state energy.
The hope is then that those regions of configurations space where
the wave function assumes appreciable values are sampled more 
efficiently. 
!eblock


!split
===== Quantum Monte Carlo Motivation =====
!bblock
The tedious part in a VMC calculation is the search for the variational
minimum. A good knowledge of the system is required in order to carry out
reasonable VMC calculations. This is not always the case, 
and often VMC calculations 
serve rather as the starting
point for so-called diffusion Monte Carlo calculations (DMC). DMC is a way of
solving exactly the many-body Schroedinger equation by means of 
a stochastic procedure. A good guess on the binding energy
and its wave function is however necessary. 
A carefully performed VMC calculation can aid in this context. 
!eblock


!split
===== Quantum Monte Carlo Motivation =====
!bblock
* Construct first a trial wave function $\psi_T(\bm{R},\bm{\alpha})$,  for a many-body system consisting of $N$ particles located at positions 
$\bm{R}=(\bm{R}_1,\dots ,\bm{R}_N)$. The trial wave function depends on $\alpha$ variational parameters $\bm{\alpha}=(\alpha_1,\dots ,\alpha_M)$.
* Then we evaluate the expectation value of the hamiltonian $H$ 
!bt
\[
   E[H]=\langle H \rangle =
   \frac{\int d\bm{R}\Psi^{\ast}_{T}(\bm{R},\bm{\alpha})H(\bm{R})\Psi_{T}(\bm{R},\bm{\alpha})}
        {\int d\bm{R}\Psi^{\ast}_{T}(\bm{R},\bm{\alpha})\Psi_{T}(\bm{R},\bm{\alpha})}.
\]
!et
* Thereafter we vary $\alpha$ according to some minimization algorithm and return to the first step.
!eblock


!split
===== Quantum Monte Carlo Motivation =====
!bblock Basic steps
Choose a trial wave function
$\psi_T(\bm{R})$.
!bt
\[
   P(\bm{R})= \frac{\left|\psi_T(\bm{R})\right|^2}{\int \left|\psi_T(\bm{R})\right|^2d\bm{R}}.
\]
!et
This is our new probability distribution function  (PDF).
The approximation to the expectation value of the Hamiltonian is now 
!bt
\[
   E[H(\bm{\alpha})] = 
   \frac{\int d\bm{R}\Psi^{\ast}_T(\bm{R},\bm{\alpha})H(\bm{R})\Psi_T(\bm{R},\bm{\alpha})}
        {\int d\bm{R}\Psi^{\ast}_T(\bm{R},\bm{\alpha})\Psi_T(\bm{R},\bm{\alpha})}.
\]
!et
!eblock


!split
===== Quantum Monte Carlo Motivation =====
!bblock
Define a new quantity
!bt
\[
   E_L(\bm{R},\bm{\alpha})=\frac{1}{\psi_T(\bm{R},\bm{\alpha})}H\psi_T(\bm{R},\bm{\alpha}),
   label{eq:locale1}
\]
!et
called the local energy, which, together with our trial PDF yields
!bt
\[
  E[H(\bm{\alpha})]= = \int P(\bm{R})E_L(\bm{R}) d\bm{R}\approx \frac{1}{N}\sum_{i=1}^NP(\bm{R_i},\bm{\alpha})E_L(\bm{R_i},\bm{\alpha})
  label{eq:vmc1}
\]
!et
with $N$ being the number of Monte Carlo samples.
!eblock





Algo:

          *  Initialisation: Fix the number of Monte Carlo steps. Choose an initial ${\bf R}$ and
                variational parameters $\alpha$ and 
                calculate
                $\left|\psi_T^{\alpha}({\bf R})\right|^2$. 
          *  Initialise the energy and the variance and start the Monte Carlo calculation.

                  *  Calculate  a trial position  ${\bf R}_p={\bf R}+r*step$
                        where $r$ is a random variable $r \in [0,1]$.
                  *  Metropolis algorithm to accept
                        or reject this move                         \[
                           w = P({\bf R}_p)/P({\bf R}).
                        \]
                  *  If the step is accepted, then we set 
                        ${\bf R}={\bf R}_p$. Update averages

          *  Finish and
compute final averages.
Observe that the jumping in space is governed by the variable *step*. Called brute-force sampling.
Need importance sampling to get more relevant sampling.


The radial Schr\"odinger equation for the hydrogen atom can be
written as
\[
-\frac{\hbar^2}{2m}\frac{\partial^2 u(r)}{\partial r^2}-
\left(\frac{ke^2}{r}-\frac{\hbar^2l(l+1)}{2mr^2}\right)u(r)=Eu(r),
\]
or with dimensionless variables
\[
-\frac{1}{2}\frac{\partial^2 u(\rho)}{\partial \rho^2}-
\frac{u(\rho)}{\rho}+\frac{l(l+1)}{2\rho^2}u(\rho)-\lambda u(\rho)=0,
label{eq:hydrodimless1}
\]
with the hamiltonian
\[
H=-\frac{1}{2}\frac{\partial^2 }{\partial \rho^2}-
\frac{1}{\rho}+\frac{l(l+1)}{2\rho^2}.
\]
Use variational parameter $\alpha$ in the trial
wave function 
\[
   u_T^{\alpha}(\rho)=\alpha\rho e^{-\alpha\rho}. 
   label{eq:trialhydrogen}
\]

!split
===== Quantum Monte Carlo =====
!block
Inserting this wave function into the expression for the
local energy $E_L$ gives
\[
   E_L(\rho)=-\frac{1}{\rho}-
              \frac{\alpha}{2}\left(\alpha-\frac{2}{\rho}\right).
\]

\begin{tabular}{rrrr}\hline
$\alpha$&$\langle H \rangle $&$\sigma^2$&$\sigma/\sqrt{N}$ \\\hline
 7.00000E-01 & -4.57759E-01 &  4.51201E-02 &  6.71715E-04 \\ 
 8.00000E-01 & -4.81461E-01 &  3.05736E-02 &  5.52934E-04 \\ 
 9.00000E-01 & -4.95899E-01 &  8.20497E-03 &  2.86443E-04 \\ 
 1.00000E-00 & -5.00000E-01 &  0.00000E+00 &  0.00000E+00 \\ 
 1.10000E+00 & -4.93738E-01 &  1.16989E-02 &  3.42036E-04 \\ 
 1.20000E+00 & -4.75563E-01 &  8.85899E-02 &  9.41222E-04 \\ 
 1.30000E+00 & -4.54341E-01 &  1.45171E-01 &  1.20487E-03 \\ 
!eblock


!split
===== Quantum Monte Carlo =====
We note that at $\alpha=1$ we obtain the exact
result, and the variance is zero, as it should. The reason is that 
we then have the exact wave function, and the action of the hamiltionan
on the wave function
\[
   H\psi = \mathrm{constant\times \psi,
\]
yields just a constant. The integral which defines various 
expectation values involving moments of the hamiltonian becomes then
\[
   \langle H^n \rangle =
   \frac{\int d{\bf R\Psi^{\ast_T({\bf R)H^n({\bf R)\Psi_T({\bf R)
        {\int d{\bf R\Psi^{\ast_T({\bf R)\Psi_T({\bf R)=
\mathrm{constant\times\frac{\int d{\bf R\Psi^{\ast_T({\bf R)\Psi_T({\bf R)
        {\int d{\bf R\Psi^{\ast_T({\bf R)\Psi_T({\bf R)=
\mathrm{constant.
\]
_This gives an important information: the exact wave function leads to zero variance_!
Variation is then performed by minimizing both the energy and the variance.





!split
===== Quantum Monte Carlo =====
!block
The helium atom consists of two electrons and a nucleus with
charge $Z=2$. 
The contribution  
to the potential energy due to the attraction from the nucleus is
\[
   -\frac{2ke^2{r_1-\frac{2ke^2{r_2,
\] 
and if we add the repulsion arising from the two 
interacting electrons, we obtain the potential energy
\[
 V(r_1, r_2)=-\frac{2ke^2{r_1-\frac{2ke^2{r_2+
               \frac{ke^2{r_{12,
\]
with the electrons separated at a distance 
$r_{12=|{\bf r_1-{\bf r_2|$.





!split
{
  ===== Quantum Monte Carlo =====


The hamiltonian becomes then
\[
   \OP{H=-\frac{\hbar^2\nabla_1^2{2m-\frac{\hbar^2\nabla_2^2{2m
          -\frac{2ke^2{r_1-\frac{2ke^2{r_2+
               \frac{ke^2{r_{12,
\]
and  Schr\"odingers equation reads
\[
   \OP{H\psi=E\psi.
\]
All observables are evaluated with respect to the probability distribution
\[
   P({\bf R)= \frac{\left|\psi_T({\bf R)\right|^2{\int \left|\psi_T({\bf R)\right|^2d{\bf R.
\]
generated by the trial wave function.   
The trial wave function must approximate an exact 
eigenstate in order that accurate results are to be obtained. 
Improved trial
wave functions also improve the importance sampling, 
reducing the cost of obtaining a certain statistical accuracy. 





!split
{
  ===== Quantum Monte Carlo =====


Choice of trial wave function for Helium:
Assume $r_1 \rightarrow 0$.
\[
   E_L({\bf R)=\frac{1{\psi_T({\bf R)H\psi_T({\bf R)=
     \frac{1{\psi_T({\bf R)\left(-\frac{1{2\nabla^2_1
     -\frac{Z{r_1\right)\psi_T({\bf R) + \mathrm{finite \hspace{0.1cmterms.
\]
\[ 
    E_L(R)=
    \frac{1{{\cal R_T(r_1)\left(-\frac{1{2\frac{d^2{dr_1^2-
     \frac{1{r_1\frac{d{dr_1
     -\frac{Z{r_1\right){\cal R_T(r_1) + \mathrm{finite\hspace{0.1cm terms
\]
For small values of $r_1$, the terms which dominate are
\[ 
    \lim_{r_1 \rightarrow 0E_L(R)=
    \frac{1{{\cal R_T(r_1)\left(-
     \frac{1{r_1\frac{d{dr_1
     -\frac{Z{r_1\right){\cal R_T(r_1),
\]
since the second derivative does not diverge due to the finiteness of 
$\Psi$ at the origin.





!split
{
===== Quantum Monte Carlo =====


This results in
\[
     \frac{1{{\cal R_T(r_1)\frac{d {\cal R_T(r_1){dr_1=-Z,
\]
and
\[
   {\cal R_T(r_1)\propto e^{-Zr_1.
\]
A similar condition applies to electrons 2 as well. 
For orbital momenta $l > 0$ we have 
\[
     \frac{1{{\cal R_T(r)\frac{d {\cal R_T(r){dr=-\frac{Z{l+1.
\]
Similarly, studying the case $r_{12\rightarrow 0$ we can write 
a possible trial wave function as
\[
   \psi_T({\bf R)=e^{-\alpha(r_1+r_2)e^{\beta r_{12.
    label{eq:wavehelium2}
\]
The last equation can be generalized to
\[
   \psi_T({\bf R)=\phi({\bf r_1)\phi({\bf r_2)\dots\phi({\bf r_N)
                   \prod_{i< jf(r_{ij),
\]
for a system with $N$ electrons or particles. 




!split
===== VMC code for helium, main part =====

#include "vmcsolver.h"
#include <iostream>

using namespace std;

int main()
{
    VMCSolver *solver = new VMCSolver();
    solver->runMonteCarloIntegration();
    return 0;

\end{lstlisting






!split[containsverbatim]
{
  }{VMC code for helium, VMC class


\begin{lstlisting
#ifndef VMCSOLVER_H
#define VMCSOLVER_H
#include <armadillo>

using namespace arma;

class VMCSolver
{
public:
    VMCSolver();
    void runMonteCarloIntegration();
\end{lstlisting






!split[containsverbatim]
{
  }{VMC code for helium, VMC class


\begin{lstlisting
private:
    double waveFunction(const mat &r);
    double localEnergy(const mat &r);
    int nDimensions, charge, nparticles;
    double stepLength, h, h2, alpha;
    long idum;
    int nCycles;
    mat rOld, rNew;
;
#endif // VMCSOLVER_H
\end{lstlisting







!split[containsverbatim]
{
  }{VMC code for helium, VMC part itself, additional functions needed


\begin{lstlisting
#include "vmcsolver.h"
#include "lib.h"
#include <armadillo>
#include <iostream>
using namespace arma;
using namespace 
\end{lstlisting





!split[containsverbatim]
{
  }{VMC code for helium, VMC part itself, initial data, can be read from command line or file


\begin{lstlisting
VMCSolver::VMCSolver() :
    nDimensions(3),
    charge(2),
    stepLength(1.0),
    nparticles(2),
    h(0.001),
    h2(1000000),
    idum(-1),
    alpha(0.5*charge),
    nCycles(1000000)
{

\end{lstlisting





!split[containsverbatim]
{
  }{VMC code for helium, VMC part itself


\begin{lstlisting
void VMCSolver::runMonteCarloIntegration()
{
    rOld = zeros<mat>(nparticles, nDimensions);
    rNew = zeros<mat>(nparticles, nDimensions);
    double waveFunctionOld = 0;
    double waveFunctionNew = 0;
    double energySum = 0;
    double energySquaredSum = 0;
    double deltaE;
\end{lstlisting





!split[containsverbatim]
{
  }{VMC code for helium, VMC part itself


\begin{lstlisting
    // initial trial positions
    for(int i = 0; i < nparticles; i++) {
        for(int j = 0; j < nDimensions; j++) {
            rOld(i,j) = stepLength * (ran2(&idum) - 0.5);
        
    
    rNew = rOld;
    // loop over Monte Carlo cycles
    for(int cycle = 0; cycle < nCycles; cycle++) {
\end{lstlisting





!split[containsverbatim]
{
  }{VMC code for helium, VMC part itself


\begin{lstlisting
        // Store the current value of the wave function
        waveFunctionOld = waveFunction(rOld);
        // New position to test
        for(int i = 0; i < nparticles; i++) {
            for(int j = 0; j < nDimensions; j++) {
                rNew(i,j) = rOld(i,j) + stepLength*(ran2(&idum) - 0.5);
            
            // Recalculate the value of the wave function
            waveFunctionNew = waveFunction(rNew);
\end{lstlisting





!split[containsverbatim]
{
  }{VMC code for helium, VMC part itself


\begin{lstlisting
            // Check for step acceptance (if yes, update position, if no, reset position)
            if(ran2(&idum) <= (waveFunctionNew*waveFunctionNew) / (waveFunctionOld*waveFunctionOld)) {
                for(int j = 0; j < nDimensions; j++) {
                    rOld(i,j) = rNew(i,j);
                    waveFunctionOld = waveFunctionNew;
                
             else {
                for(int j = 0; j < nDimensions; j++) {
                    rNew(i,j) = rOld(i,j);
                
            
\end{lstlisting





!split[containsverbatim]
{
  }{VMC code for helium, VMC part itself


\begin{lstlisting
            // update energies
            deltaE = localEnergy(rNew);
            energySum += deltaE;
            energySquaredSum += deltaE*deltaE;
        
    
    double energy = energySum/(nCycles * nparticles);
    double energySquared = energySquaredSum/(nCycles * nparticles);
    cout << "Energy: " << energy << " Energy (squared sum): " << energySquared << endl;

\end{lstlisting





!split[containsverbatim]
{
  }{VMC code for helium, VMC part, the local energy


\begin{lstlisting
double VMCSolver::localEnergy(const mat &r)
{
    mat rPlus = zeros<mat>(nparticles, nDimensions);
    mat rMinus = zeros<mat>(nparticles, nDimensions);
    rPlus = rMinus = r;
    double waveFunctionMinus = 0;
    double waveFunctionPlus = 0;
    double waveFunctionCurrent = waveFunction(r);
\end{lstlisting





!split[containsverbatim]
{
  }{VMC code for helium, VMC part, the local energy


\begin{lstlisting
    // Kinetic energy
    double kineticEnergy = 0;
    for(int i = 0; i < nparticles; i++) {
        for(int j = 0; j < nDimensions; j++) {
            rPlus(i,j) += h;
            rMinus(i,j) -= h;
            waveFunctionMinus = waveFunction(rMinus);
            waveFunctionPlus = waveFunction(rPlus);
            kineticEnergy -= (waveFunctionMinus + waveFunctionPlus - 2 * waveFunctionCurrent);
            rPlus(i,j) = r(i,j);
            rMinus(i,j) = r(i,j);
        
    
    kineticEnergy = 0.5 * h2 * kineticEnergy / waveFunctionCurrent;
\end{lstlisting





!split[containsverbatim]
{
  }{VMC code for helium, VMC part, the local energy


\begin{lstlisting
    // Potential energy
    double potentialEnergy = 0;
    double rSingleParticle  = 0;
    for(int i = 0; i < nparticles; i++) {
        rSingleParticle  = 0;
        for(int j = 0; j < nDimensions; j++) {
            rSingleParticle  += r(i,j)*r(i,j);
        
        potentialEnergy -= charge / sqrt(rSingleParticle );
    
\end{lstlisting





!split[containsverbatim]
{
  }{VMC code for helium, VMC part, the local energy


\begin{lstlisting
    // Contribution from electron-electron potential
    double r12 = 0;
    for(int i = 0; i < nparticles; i++) {
        for(int j = i + 1; j < nparticles; j++) {
            r12 = 0;
            for(int k = 0; k < nDimensions; k++) {
                r12 += (r(i,k) - r(j,k)) * (r(i,k) - r(j,k));
            
            potentialEnergy += 1 / sqrt(r12);
        
    
    return kineticEnergy + potentialEnergy;

\end{lstlisting





!split[containsverbatim]
{
  }{VMC code for helium, VMC part, the wave function


\begin{lstlisting
double VMCSolver::waveFunction(const mat &r)
{
    double argument = 0;
    for(int i = 0; i < nparticles; i++) {
        double rSingleParticle  = 0;
        for(int j = 0; j < nDimensions; j++) {
            rSingleParticle  += r(i,j) * r(i,j);
        
        argument += sqrt(rSingleParticle );
    
    return exp(-argument * alpha);

\end{lstlisting















!split
{
  }{Structuring the code


During the development of our code we need to make several checks. It is also very instructive to compute a closed form expression for the local energy. Since our wave function is rather simple  it is straightforward
to find an analytic expressions.  Consider first the case of the simple helium function 
\[
   \Psi_T(\mathbf{r_1,\mathbf{r_2) = e^{-\alpha(r_1+r_2)
\]
The local energy is for this case 
\[ 
E_{L1 = \left(\alpha-Z\right)\left(\frac{1{r_1+\frac{1{r_2\right)+\frac{1{r_{12-\alpha^2
\]
which gives an expectation value for the local energy given by
\[
\langle E_{L1 \rangle = \alpha^2-2\alpha\left(Z-\frac{5{16\right)
\]
In our project, the simple form is
\[
   \Psi_T(\mathbf{r_1,\mathbf{r_2) = e^{-\alpha\omega(r_1^2+r_2^2)/2
\]
Find the contribution to the local energy!




!split
{
  }{Structuring the code


With closed form formulae we  can speed up the computation of the correlation. In our case
we write it as 
\[
\Psi_C= \exp{\left\{\sum_{i<j\frac{ar_{ij{1+\beta r_{ij\right\,
\]
which means that the gradient needed for the so-called quantum force and local energy 
can be calculated analytically.
This will speed up your code since the computation of the correlation part and the Slater determinant are the most 
time consuming parts in your code.  

We will refer to this correlation function as $\Psi_C$ or the \emph{linear Pad\'e-Jastrow.





!split
{
  }{Structuring the code


We can test this by computing the local energy for our helium wave function

\[
   \psi_{T({\bf r_1,{\bf r_2) = 
   \exp{\left(-\alpha(r_1+r_2)\right)
   \exp{\left(\frac{r_{12{2(1+\beta r_{12)\right), 
\]

with $\alpha$ and $\beta$ as variational parameters.

The local energy is for this case 
\[ 
E_{L2 = E_{L1+\frac{1{2(1+\beta r_{12)^2\left\{\frac{\alpha(r_1+r_2){r_{12(1-\frac{\mathbf{r_1\mathbf{r_2{r_1r_2)-\frac{1{2(1+\beta r_{12)^2-\frac{2{r_{12+\frac{2\beta{1+\beta r_{12\right\
\]
It is very useful to test your code against these expressions. It means also that you don't need to
compute a derivative numerically as discussed in the above code example. 






!split
{
  }{Your tasks for today and till next week



*  Implement the closed form expression for the local energy
*  Convince yourself that the closed form expressions are correct. 
*  Implement the above expressions for the helium atom with two electrons.
*  Start working on exercises 1a and 1b. 







!split
{
  }{Importance sampling, what we want to do


We need to replace the brute force
Metropolis algorithm with a walk in coordinate space biased by the trial wave function.
This approach is based on the Fokker-Planck equation and the Langevin equation for generating a trajectory in coordinate space.  This is explained later.

For a diffusion process characterized by a time-dependent probability density $P(x,t)$ in one dimension the Fokker-Planck
equation reads (for one particle /walker) 
\[
   \frac{\partial P{\partial t = D\frac{\partial {\partial x\left(\frac{\partial {\partial x -F\right)P(x,t),
\]
where $F$ is a drift term and $D$ is the diffusion coefficient. 

The new positions in coordinate space are given as the solutions of the Langevin equation using Euler's method, namely,
we go from the Langevin equation
\[ 
   \frac{\partial x(t){\partial t = DF(x(t)) +\eta,
\]
with $\eta$ a random variable,
yielding a new position 
\[
   y = x+DF(x)\Delta t +\xi,
\]
where $\xi$ is gaussian random variable and $\Delta t$ is a chosen time step. 





!split
  }{Importance sampling, what we want to do


The process of isotropic diffusion characterized by a time-dependent probability density $P(\bfv{x,t)$ obeys (as an approximation) 
the so-called Fokker-Planck equation 
$$
   \frac{\partial P{\partial t = \sum_i D\frac{\partial {\partial \bfv{x_i\left(\frac{\partial {\partial \bfv{x_i -\bfv{F_i\right)P(\bfv{x,t),
$$
where $\bfv{F_i$ is the $i^{th$ component of the drift term (drift velocity) caused by an external potential, and $D$ is the diffusion coefficient. The convergence to a stationary probability density can be obtained by setting the left hand side to zero. The resulting equation will be satisfied if and only if all the terms of the sum are equal zero,
$$
\frac{\partial^2 P{\partial {\bfv{x_i^2 = P\frac{\partial{\partial {\bfv{x_i\bfv{F_i + \bfv{F_i\frac{\partial{\partial {\bfv{x_iP.
$$





!split
{
  }{Importance sampling, what we want to do


The drift vector should be of the form $\bfv{F = g(\bfv{x) \frac{\partial P{\partial \bfv{x$. Then,
$$
\frac{\partial^2 P{\partial {\bfv{x_i^2 = P\frac{\partial g{\partial P\left( \frac{\partial P{\partial {\bfv{x_i  \right)^2 + P g \frac{\partial ^2 P{\partial {\bfv{x_i ^2  + g \left( \frac{\partial P{\partial {\bfv{x_i  \right)^2.
$$
The condition of stationary density means that the left hand side equals zero. In other words, the terms containing first and second derivatives have to cancel each other. It is possible only if $g = \frac{1{P$, which yields
\begin{equationlabel{quantumForceEQ
\boxed{\bfv{F = 2\frac{1{\Psi_T\nabla\Psi_T,
\end{equation
which is known as the so-called \emph{quantum force. This term is responsible for pushing the walker towards regions of configuration space where the trial wave function is large, increasing the efficiency of the simulation in contrast to the Metropolis algorithm where the walker has the same probability of moving in every direction.








!split
{
  }{Importance Sampling


The Fokker-Planck equation yields a (the solution to the equation) transition probability given by the Green's function
\[
  G(y,x,\Delta t) = \frac{1{(4\pi D\Delta t)^{3N/2 \exp{\left(-(y-x-D\Delta t F(x))^2/4D\Delta t\right)
\]
which in turn means that our brute force Metropolis algorithm
\[ 
    A(y,x) = \mathrm{min(1,q(y,x))),
\]
with $q(y,x) = |\Psi_T(y)|^2/|\Psi_T(x)|^2$ is now replaced by
\[
q(y,x) = \frac{G(x,y,\Delta t)|\Psi_T(y)|^2{G(y,x,\Delta t)|\Psi_T(x)|^2
\]
Read more in Thijssen's text chapters 8.8 and 12.2.






!split[containsverbatim]
{
  }{Importance sampling, new positions
%  \begin{block{


!split
{
  }{Closed form expressions for quantum force


The general derivative formula of the Jastrow factor is
\[
\frac{1{\Psi_C\frac{\partial \Psi_C{\partial x_k =
\sum_{i=1^{k-1\frac{\partial g_{ik{\partial x_k
+
\sum_{i=k+1^{N\frac{\partial g_{ki{\partial x_k
\]
However, 
with our
\[
\Psi_C=\prod_{i< jg(r_{ij)= \exp{\left\{\sum_{i<j\frac{ar_{ij{1+\beta r_{ij\right\,
\]
the gradient needed for the quantum force and local energy is easy to compute.  
We get for particle  $k$
\[
\frac{ \nabla_k \Psi_C{ \Psi_C = \sum_{j\ne k\frac{{\bf r_{kj{r_{kj\frac{a{(1+\beta r_{kj)^2,
\]
which is rather easy to code.  Remember to sum over all particles  when you compute the local energy.




!split
{
  }{Your tasks from the previous  weeks plus new tasks



*  Implement the closed form expression for the local energy and the so-called quantum force
*  Convince yourself that the closed form expressions are correct.
*  Implement the closed form expressions for systems with more than two electrons.
*  Start implementing importance sampling, part 1c
*  Finish part 1a and begin part 1b.  
*  You need to produce random numbers with a Gaussian distribution.
*  Reading task: Thijssen's text chapters 8.8 and 12.2.

